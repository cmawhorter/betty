import { ok } from 'assert';
import { writeFileSync } from 'fs';
import { dirname } from 'path';
import { promisify } from 'util';

import { copy, emptyDir } from 'fs-extra';

import { installExternalDependencies } from './common/package-managers.js';

import { Task } from './task.js';

export const PackageManagers = {
  npm: 'npm',
  yarn: 'yarn',
};

export class BuildTask extends Task {
  constructor({ destination } = {}) {
    super();
    this.destination = destination;
  }
}

export class PackagedBuildTask extends BuildTask {
  static isValidPackageManager(packageManager) {
    return packageManager in PackageManagers;
  }

  constructor({
    dependencies,
    packageManager,
    destination,
  } = {}) {
    super({ destination });
    ok(PackagedBuildTask.isValidPackageManager(packageManager),
      `invalid packageManager; received "${packageManager}" but should be one of "${Object.keys(PackageManagers).join('", "')}"`);
    this.packageManager = packageManager;
    this.dependencies = dependencies || {};
  }

  async createDestination() {
    await emptyDir(this.destination);
  }

  writePackageJson() {
    const target = Task.path(this.destination, 'package.json');
    const { dependencies } = this;
    writeFileSync(target, JSON.stringify({
      description:    'This file is automatically generated by betty for unbundled dependencies.',
      dependencies,
    }, null, 2));
  }

  packageManagerInstall() {
    installExternalDependencies(this.destination, this.packageManager);
  }

  async _before(betty) {
    await this.createDestination();
    this.writePackageJson();
    this.packageManagerInstall();
  }

  async _run(betty) {
    // noop
  }
}

export class PackageOnlyBuildTask extends PackagedBuildTask {
  constructor({
    destination,
    dependencies,
    packageManager,
    sourcePath,
  }) {
    super({ destination, dependencies, packageManager });
    this.sourcePath = sourcePath;
  }

  async _before(betty) {
    await super._before(betty);
  }

  async _run(betty) {
    await copy(this.sourcePath, this.destination, {
      dereference: true,
    });
  }
}

export class RollupBuildTask extends PackagedBuildTask {
  constructor({
    rollup,
    destination,
    dependencies,
    packageManager,
    rollupConfig,
  }) {
    super({ destination, dependencies, packageManager });
    this.rollup = rollup;
    this.rollupConfig = rollupConfig;
  }

  async _run(betty) {
    const bundle = await this.rollup.rollup(this.rollupConfig);
    await bundle.write(this.rollupConfig.output);
  }
}

export class WebpackBuildTask extends PackagedBuildTask {
  constructor({
    webpack,
    destination,
    dependencies,
    packageManager,
    webpackConfig,
  }) {
    super({ destination, dependencies, packageManager });
    this.webpack = webpack;
    this.webpackConfig = webpackConfig;
  }

  async _run(betty) {
    return new Promise((resolve, reject) => {
      this.webpack(this.webpackConfig, (err, stats) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
}
