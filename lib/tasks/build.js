import { ok } from 'assert';
import { dirname } from 'path';

import { sync as mkdirpSync } from 'mkdirp';

import { installExternalDependencies } from './common/package-managers.js';

import { Task } from './task.js';

export class BuildTask extends Task {
  constructor({
    dependencies,
    packageManager,
    destination,
  } = {}) {
    super();
    this.packageManager = packageManager;
    this.dependencies = dependencies || {};
    this.destination = destination;
  }

  createDestination(cwd) {
    const target = joinPath(cwd, this.destination);
    mkdirpSync(target);
  }

  writePackageJson(cwd) {
    const target = joinPath(cwd, this.destination, 'package.json');
    const { dependencies } = this;
    fs.writeFileSync(packageJson, JSON.stringify({
      description:    'This file is automatically generated by betty for unbundled dependencies.',
      dependencies,
    }, null, 2));
  }

  packageManagerInstall(cwd) {
    const target = joinPath(cwd, this.destination, 'package.json');
    installExternalDependencies(cwd, this.packageManager);
  }

  async _before(betty) {
    this.createDestination(betty.cwd);
    this.writePackageJson(betty.cwd);
    this.packageManagerInstall(betty.cwd);
  }

  async _run(betty) {
    // noop
  }
}

export class RollupBuildTask extends BuildTask {
  constructor({
    dependencies,
    rollupConfig,
  }) {
    super({ dependencies });
    this.rollupConfig = rollupConfig || RollupBuildTask.createDefaultRollupConfig();
  }

  get destination() {
    const { rollupConfig } = this;
    let output;
    if (Array.isArray(rollupConfig.output)) {
      output = rollupConfig.output[0];
    }
    else {
      output = rollupConfig.output;
    }
    ok(output && output.file, 'unable to determine output');
    return dirname(output.file);
  }

  async _run(betty) {
    const rollup = await import('rollup');
    const bundle = await rollup.rollup(this.rollupConfig);
    await bundle.write(this.rollupConfig.output);
  }
}
